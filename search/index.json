[{"content":"复合类型 字符串与切片 切片 一个示例代码和错误解析\n1 2 3 4 5 6 7 8 9 10 11 12 fn main() { let mut s = String::from(\u0026#34;hello world\u0026#34;); let word = first_word(\u0026amp;s); s.clear(); // error! println!(\u0026#34;the first word is: {}\u0026#34;, word); } fn first_word(s: \u0026amp;String) -\u0026gt; \u0026amp;str { \u0026amp;s[..1] } 错误原因：当我们已经有了可变借用时，就无法再拥有不可变的借用。因为 clear 需要清空改变 String，因此它需要一个可变借用（利用 VSCode 可以看到该方法的声明是 pub fn clear(\u0026amp;mut self) ，参数是对自身的可变借用 ）；而之后的 println! 又使用了不可变借用，也就是在 s.clear() 处可变借用与不可变借用试图同时生效，因此编译无法通过。\nRust中的字符串 当 Rust 用户提到字符串时，往往指的就是 String 类型和 \u0026amp;str 字符串切片类型，这两个类型都是 UTF-8 编码。\nString 与 \u0026amp;str 的转换 在之前的代码中，已经见到好几种从 \u0026amp;str 类型生成 String 类型的操作：\nString::from(\u0026quot;hello,world\u0026quot;) \u0026quot;hello,world\u0026quot;.to_string() 那么如何将 String 类型转为 \u0026amp;str 类型呢？答案很简单，取引用即可：\n1 2 3 4 5 6 7 8 9 10 fn main() { let s = String::from(\u0026#34;hello,world!\u0026#34;); say_hello(\u0026amp;s); say_hello(\u0026amp;s[..]); say_hello(s.as_str()); } fn say_hello(s: \u0026amp;str) { println!(\u0026#34;{}\u0026#34;,s); } 字符串切片 字符串切片是非常危险的操作，因为切片的索引是通过字节来进行，但是字符串又是 UTF-8 编码，因此你无法保证索引的字节刚好落在字符的边界上，例如：\n1 2 3 let hello = \u0026#34;中国人\u0026#34;; let s = \u0026amp;hello[0..2]; 运行上面的程序，会直接造成崩溃。我们索引的字节落在了 中 字符的内部，这种返回没有任何意义。因此在通过索引区间来访问字符串时，需要格外的小心，一不注意，就会导致你程序的崩溃！\n","date":"2022-09-14T14:08:08+08:00","permalink":"https://figureair.github.io/p/rust%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/","title":"Rust学习随笔-复合类型"}]