[{"content":"前言 大部分内容摘录自**《Rust语言圣经》**，仅用于自主复习。\n字符串与切片 切片 一个示例代码和错误解析\n1 2 3 4 5 6 7 8 9 10 11 12 fn main() { let mut s = String::from(\u0026#34;hello world\u0026#34;); let word = first_word(\u0026amp;s); s.clear(); // error! println!(\u0026#34;the first word is: {}\u0026#34;, word); } fn first_word(s: \u0026amp;String) -\u0026gt; \u0026amp;str { \u0026amp;s[..1] } 错误原因：当我们已经有了可变借用时，就无法再拥有不可变的借用。因为 clear 需要清空改变 String，因此它需要一个可变借用（利用 VSCode 可以看到该方法的声明是 pub fn clear(\u0026amp;mut self) ，参数是对自身的可变借用 ）；而之后的 println! 又使用了不可变借用，也就是在 s.clear() 处可变借用与不可变借用试图同时生效，因此编译无法通过。\nRust中的字符串 当 Rust 用户提到字符串时，往往指的就是 String 类型和 \u0026amp;str 字符串切片类型，这两个类型都是 UTF-8 编码。\nString 与 \u0026amp;str 的转换 在之前的代码中，已经见到好几种从 \u0026amp;str 类型生成 String 类型的操作：\nString::from(\u0026quot;hello,world\u0026quot;) \u0026quot;hello,world\u0026quot;.to_string() 那么如何将 String 类型转为 \u0026amp;str 类型呢？答案很简单，取引用即可：\n1 2 3 4 5 6 7 8 9 10 fn main() { let s = String::from(\u0026#34;hello,world!\u0026#34;); say_hello(\u0026amp;s); say_hello(\u0026amp;s[..]); say_hello(s.as_str()); } fn say_hello(s: \u0026amp;str) { println!(\u0026#34;{}\u0026#34;,s); } 字符串切片 字符串切片是非常危险的操作，因为切片的索引是通过字节来进行，但是字符串又是 UTF-8 编码，因此你无法保证索引的字节刚好落在字符的边界上，例如：\n1 2 3 let hello = \u0026#34;中国人\u0026#34;; let s = \u0026amp;hello[0..2]; 运行上面的程序，会直接造成崩溃。我们索引的字节落在了 中 字符的内部，这种返回没有任何意义。因此在通过索引区间来访问字符串时，需要格外的小心，一不注意，就会导致你程序的崩溃！\n操作字符串 追加 (Push) 在字符串尾部可以使用 push() 方法追加字符 char，也可以使用 push_str() 方法追加字符串字面量。这两个方法都是在原有的字符串上追加，并不会返回新的字符串。由于字符串追加操作要修改原来的字符串，则该字符串必须是可变的，即字符串变量必须由 mut 关键字修饰。\n1 2 3 4 5 6 7 8 fn main() { let mut s = String::from(\u0026#34;Hello \u0026#34;); s.push(\u0026#39;r\u0026#39;); println!(\u0026#34;追加字符 push() -\u0026gt; {}\u0026#34;, s); s.push_str(\u0026#34;ust!\u0026#34;); println!(\u0026#34;追加字符串 push_str() -\u0026gt; {}\u0026#34;, s); } 插入 (Insert) 可以使用 insert() 方法插入单个字符 char，也可以使用 insert_str() 方法插入字符串字面量，与 push() 方法不同，这俩方法需要传入两个参数，第一个参数是字符（串）插入位置的索引，第二个参数是要插入的字符（串），索引从 0 开始计数，如果越界则会发生错误。由于字符串插入操作要修改原来的字符串，则该字符串必须是可变的，即字符串变量必须由 mut 关键字修饰。\n1 2 3 4 5 6 7 fn main() { let mut s = String::from(\u0026#34;Hello rust!\u0026#34;); s.insert(5, \u0026#39;,\u0026#39;); println!(\u0026#34;插入字符 insert() -\u0026gt; {}\u0026#34;, s); s.insert_str(6, \u0026#34; I like\u0026#34;); println!(\u0026#34;插入字符串 insert_str() -\u0026gt; {}\u0026#34;, s); } 替换 (Replace) 1、replace\n该方法可适用于 String 和 \u0026amp;str 类型。replace() 方法接收两个参数，第一个参数是要被替换的字符串，第二个参数是新的字符串。该方法会替换所有匹配到的字符串。该方法是返回一个新的字符串，而不是操作原来的字符串。\n1 2 3 4 5 fn main() { let string_replace = String::from(\u0026#34;I like rust. Learning rust is my favorite!\u0026#34;); let new_string_replace = string_replace.replace(\u0026#34;rust\u0026#34;, \u0026#34;RUST\u0026#34;); dbg!(new_string_replace); } 2、replacen\n该方法可适用于 String 和 \u0026amp;str 类型。replacen() 方法接收三个参数，前两个参数与 replace() 方法一样，第三个参数则表示替换的个数。该方法是返回一个新的字符串，而不是操作原来的字符串。\n1 2 3 4 5 fn main() { let string_replace = \u0026#34;I like rust. Learning rust is my favorite!\u0026#34;; let new_string_replacen = string_replace.replacen(\u0026#34;rust\u0026#34;, \u0026#34;RUST\u0026#34;, 1); dbg!(new_string_replacen); } 3、replace_range\n该方法仅适用于 String 类型。replace_range 接收两个参数，第一个参数是要替换字符串的范围（Range），第二个参数是新的字符串。该方法是直接操作原来的字符串，不会返回新的字符串。该方法需要使用 mut 关键字修饰。\n1 2 3 4 5 fn main() { let mut string_replace_range = String::from(\u0026#34;I like rust!\u0026#34;); string_replace_range.replace_range(7..8, \u0026#34;R\u0026#34;); dbg!(string_replace_range); } 删除 (Delete) 与字符串删除相关的方法有 4 个，他们分别是 pop()，remove()，truncate()，clear()。这四个方法仅适用于 String 类型。\n1、 pop —— 删除并返回字符串的最后一个字符\n该方法是直接操作原来的字符串。但是存在返回值，其返回值是一个 Option 类型，如果字符串为空，则返回 None。\n1 2 3 4 5 6 7 8 fn main() { let mut string_pop = String::from(\u0026#34;rust pop 中文!\u0026#34;); let p1 = string_pop.pop(); let p2 = string_pop.pop(); dbg!(p1); dbg!(p2); dbg!(string_pop); } 2、 remove —— 删除并返回字符串中指定位置的字符\n该方法是直接操作原来的字符串。但是存在返回值，其返回值是删除位置的字符串，只接收一个参数，表示该字符起始索引位置。remove() 方法是按照字节来处理字符串的，如果参数所给的位置不是合法的字符边界，则会发生错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 fn main() { let mut string_remove = String::from(\u0026#34;测试remove方法\u0026#34;); println!( \u0026#34;string_remove 占 {} 个字节\u0026#34;, std::mem::size_of_val(string_remove.as_str()) ); // 删除第一个汉字 string_remove.remove(0); // 下面代码会发生错误 // string_remove.remove(1); // 直接删除第二个汉字 // string_remove.remove(3); dbg!(string_remove); } 3、truncate —— 删除字符串中从指定位置开始到结尾的全部字符\n该方法是直接操作原来的字符串。无返回值。该方法 truncate() 方法是按照字节来处理字符串的，如果参数所给的位置不是合法的字符边界，则会发生错误。\n1 2 3 4 5 fn main() { let mut string_truncate = String::from(\u0026#34;测试truncate\u0026#34;); string_truncate.truncate(3); dbg!(string_truncate); } 1 string_truncate = \u0026#34;测\u0026#34; 4、clear —— 清空字符串\n该方法是直接操作原来的字符串。调用后，删除字符串中的所有字符，相当于 truncate() 方法参数为 0 的时候。\n1 2 3 4 5 fn main() { let mut string_clear = String::from(\u0026#34;string clear\u0026#34;); string_clear.clear(); dbg!(string_clear); } 连接 (Concatenate) 1、使用 + 或者 += 连接字符串\n使用 + 或者 += 连接字符串，要求右边的参数必须为字符串的切片引用（Slice）类型。其实当调用 + 的操作符时，相当于调用了 std::string 标准库中的 add() 方法，这里 add() 方法的第二个参数是一个引用的类型。因此我们在使用 +， 必须传递切片引用类型。不能直接传递 String 类型。+ 和 += 都是返回一个新的字符串。所以变量声明可以不需要 mut 关键字修饰。\n1 2 3 4 5 6 7 8 9 10 11 fn main() { let string_append = String::from(\u0026#34;hello \u0026#34;); let string_rust = String::from(\u0026#34;rust\u0026#34;); // \u0026amp;string_rust会自动解引用为\u0026amp;str // 在下句中，string_append的所有权被转移走了，因此后面不能再使用string_append let result = string_append + \u0026amp;string_rust; let mut result = result + \u0026#34;!\u0026#34;; result += \u0026#34;!!!\u0026#34;; println!(\u0026#34;连接字符串 + -\u0026gt; {}\u0026#34;, result); } 2、使用 format! 连接字符串\nformat! 这种方式适用于 String 和 \u0026amp;str 。format! 的用法与 print! 的用法类似。\n1 2 3 4 5 6 fn main() { let s1 = \u0026#34;hello\u0026#34;; let s2 = String::from(\u0026#34;rust\u0026#34;); let s = format!(\u0026#34;{} {}!\u0026#34;, s1, s2); println!(\u0026#34;{}\u0026#34;, s); } 1 hello rust! 字符串转义 转义输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 fn main() { // 通过 \\ + 字符的十六进制表示，转义输出一个字符 let byte_escape = \u0026#34;I\u0026#39;m writing \\x52\\x75\\x73\\x74!\u0026#34;; println!(\u0026#34;What are you doing\\x3F (\\\\x3F means ?) {}\u0026#34;, byte_escape); // \\u 可以输出一个 unicode 字符 let unicode_codepoint = \u0026#34;\\u{211D}\u0026#34;; let character_name = \u0026#34;\\\u0026#34;DOUBLE-STRUCK CAPITAL R\\\u0026#34;\u0026#34;; println!( \u0026#34;Unicode character {} (U+211D) is called {}\u0026#34;, unicode_codepoint, character_name ); // 换行了也会保持之前的字符串格式 let long_string = \u0026#34;String literals can span multiple lines. The linebreak and indentation here -\u0026gt;\\ \u0026lt;- can be escaped too!\u0026#34;; println!(\u0026#34;{}\u0026#34;, long_string); } 保持原样\n1 2 3 4 5 6 7 8 9 10 11 12 13 fn main() { println!(\u0026#34;{}\u0026#34;, \u0026#34;hello \\\\x52\\\\x75\\\\x73\\\\x74\u0026#34;); let raw_str = r\u0026#34;Escapes don\u0026#39;t work here: \\x3F \\u{211D}\u0026#34;; println!(\u0026#34;{}\u0026#34;, raw_str); // 如果字符串包含双引号，可以在开头和结尾加 # let quotes = r#\u0026#34;And then I said: \u0026#34;There is no escape!\u0026#34;\u0026#34;#; println!(\u0026#34;{}\u0026#34;, quotes); // 如果还是有歧义，可以继续增加，没有限制 let longer_delimiter = r###\u0026#34;A string with \u0026#34;# in it. And even \u0026#34;##!\u0026#34;###; println!(\u0026#34;{}\u0026#34;, longer_delimiter); } 操作UTF-8字符串 字符\n如果你想要以 Unicode 字符的方式遍历字符串，最好的办法是使用 chars 方法，例如：\n1 2 3 for c in \u0026#34;中国人\u0026#34;.chars() { println!(\u0026#34;{}\u0026#34;, c); } 字节\n这种方式是返回字符串的底层字节数组表现形式：\n1 2 3 for b in \u0026#34;中国人\u0026#34;.bytes() { println!(\u0026#34;{}\u0026#34;, b); } 获取子串\n想要准确的从 UTF-8 字符串中获取子串是较为复杂的事情，例如想要从 holla中国人नमस्ते 这种变长的字符串中取出某一个子串，使用标准库你是做不到的。 你需要在 crates.io 上搜索 utf8 来寻找想要的功能。\n可以考虑尝试下这个库：utf8_slice。\n","date":"2022-09-14T14:08:08+08:00","permalink":"https://figureair.github.io/p/rust%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/","title":"Rust学习随笔-复合类型"}]