[{"content":"前言 生活节奏的逐渐加快和疫情带来的浮躁，已经让我很难沉下心去看完一场电影。而多亏自己以前会有在微博记录电影观后感的习惯，我翻了翻主页，距离我上次看电影已经有6个月的跨度了。当然了，今天不是来聊这半年为什么我无法沉浸在一部电影里以及这一现象带来的的反思（先挖个坑），而是来讲讲这一次观看的《壮志凌云2：独行侠》（亦或者《美式战狼2》）。\n我不准备从剧情的前后来记录流水账（这没有意义），也不准备娓娓而谈，深挖细节（我好像做不到）。只是随性而写，把电影里一些我感到有趣的地方以及当时的想法描绘一番。文笔不佳，还请见谅，以后努力。\n好的续集需要做到什么？ 当我把电影下载到桌面，鼠标移动到图标上时，我的第一个念头不是这部片子会不会好看，而是我会不会看不懂剧情，毕竟这是一部续集电影，而续集电影往往需要有粘性的观众，能够了解前作的相关背景。而我对前作的认知，仅仅停留在它的上映时间1986年和主角汤姆·克鲁斯。于是，我忐忑的打开播放器，在\n散言碎语 ","date":"2022-09-23T21:17:57+08:00","image":"https://figureair.github.io/1.webp","permalink":"https://figureair.github.io/p/%E5%A3%AE%E5%BF%97%E5%87%8C%E4%BA%912%E7%8B%AC%E8%A1%8C%E4%BE%A0/","title":"壮志凌云2：独行侠"},{"content":"前言 大部分内容摘录自《Rust语言圣经》，仅用于自主复习。\n字符串与切片 切片 一个示例代码和错误解析\n1 2 3 4 5 6 7 8 9 10 11 12 fn main() { let mut s = String::from(\u0026#34;hello world\u0026#34;); let word = first_word(\u0026amp;s); s.clear(); // error! println!(\u0026#34;the first word is: {}\u0026#34;, word); } fn first_word(s: \u0026amp;String) -\u0026gt; \u0026amp;str { \u0026amp;s[..1] } 错误原因：当我们已经有了可变借用时，就无法再拥有不可变的借用。因为 clear 需要清空改变 String，因此它需要一个可变借用（利用 VSCode 可以看到该方法的声明是 pub fn clear(\u0026amp;mut self) ，参数是对自身的可变借用 ）；而之后的 println! 又使用了不可变借用，也就是在 s.clear() 处可变借用与不可变借用试图同时生效，因此编译无法通过。\nRust中的字符串 当 Rust 用户提到字符串时，往往指的就是 String 类型和 \u0026amp;str 字符串切片类型，这两个类型都是 UTF-8 编码。\nString 与 \u0026amp;str 的转换 在之前的代码中，已经见到好几种从 \u0026amp;str 类型生成 String 类型的操作：\nString::from(\u0026quot;hello,world\u0026quot;) \u0026quot;hello,world\u0026quot;.to_string() 那么如何将 String 类型转为 \u0026amp;str 类型呢？答案很简单，取引用即可：\n1 2 3 4 5 6 7 8 9 10 fn main() { let s = String::from(\u0026#34;hello,world!\u0026#34;); say_hello(\u0026amp;s); say_hello(\u0026amp;s[..]); say_hello(s.as_str()); } fn say_hello(s: \u0026amp;str) { println!(\u0026#34;{}\u0026#34;,s); } 字符串切片 字符串切片是非常危险的操作，因为切片的索引是通过字节来进行，但是字符串又是 UTF-8 编码，因此你无法保证索引的字节刚好落在字符的边界上，例如：\n1 2 3 let hello = \u0026#34;中国人\u0026#34;; let s = \u0026amp;hello[0..2]; 运行上面的程序，会直接造成崩溃。我们索引的字节落在了 中 字符的内部，这种返回没有任何意义。因此在通过索引区间来访问字符串时，需要格外的小心，一不注意，就会导致你程序的崩溃！\n操作字符串 追加 (Push) 在字符串尾部可以使用 push() 方法追加字符 char，也可以使用 push_str() 方法追加字符串字面量。这两个方法都是在原有的字符串上追加，并不会返回新的字符串。由于字符串追加操作要修改原来的字符串，则该字符串必须是可变的，即字符串变量必须由 mut 关键字修饰。\n1 2 3 4 5 6 7 8 fn main() { let mut s = String::from(\u0026#34;Hello \u0026#34;); s.push(\u0026#39;r\u0026#39;); println!(\u0026#34;追加字符 push() -\u0026gt; {}\u0026#34;, s); s.push_str(\u0026#34;ust!\u0026#34;); println!(\u0026#34;追加字符串 push_str() -\u0026gt; {}\u0026#34;, s); } 插入 (Insert) 可以使用 insert() 方法插入单个字符 char，也可以使用 insert_str() 方法插入字符串字面量，与 push() 方法不同，这俩方法需要传入两个参数，第一个参数是字符（串）插入位置的索引，第二个参数是要插入的字符（串），索引从 0 开始计数，如果越界则会发生错误。由于字符串插入操作要修改原来的字符串，则该字符串必须是可变的，即字符串变量必须由 mut 关键字修饰。\n1 2 3 4 5 6 7 fn main() { let mut s = String::from(\u0026#34;Hello rust!\u0026#34;); s.insert(5, \u0026#39;,\u0026#39;); println!(\u0026#34;插入字符 insert() -\u0026gt; {}\u0026#34;, s); s.insert_str(6, \u0026#34; I like\u0026#34;); println!(\u0026#34;插入字符串 insert_str() -\u0026gt; {}\u0026#34;, s); } 替换 (Replace) 1、replace\n该方法可适用于 String 和 \u0026amp;str 类型。replace() 方法接收两个参数，第一个参数是要被替换的字符串，第二个参数是新的字符串。该方法会替换所有匹配到的字符串。该方法是返回一个新的字符串，而不是操作原来的字符串。\n1 2 3 4 5 fn main() { let string_replace = String::from(\u0026#34;I like rust. Learning rust is my favorite!\u0026#34;); let new_string_replace = string_replace.replace(\u0026#34;rust\u0026#34;, \u0026#34;RUST\u0026#34;); dbg!(new_string_replace); } 2、replacen\n该方法可适用于 String 和 \u0026amp;str 类型。replacen() 方法接收三个参数，前两个参数与 replace() 方法一样，第三个参数则表示替换的个数。该方法是返回一个新的字符串，而不是操作原来的字符串。\n1 2 3 4 5 fn main() { let string_replace = \u0026#34;I like rust. Learning rust is my favorite!\u0026#34;; let new_string_replacen = string_replace.replacen(\u0026#34;rust\u0026#34;, \u0026#34;RUST\u0026#34;, 1); dbg!(new_string_replacen); } 3、replace_range\n该方法仅适用于 String 类型。replace_range 接收两个参数，第一个参数是要替换字符串的范围（Range），第二个参数是新的字符串。该方法是直接操作原来的字符串，不会返回新的字符串。该方法需要使用 mut 关键字修饰。\n1 2 3 4 5 fn main() { let mut string_replace_range = String::from(\u0026#34;I like rust!\u0026#34;); string_replace_range.replace_range(7..8, \u0026#34;R\u0026#34;); dbg!(string_replace_range); } 删除 (Delete) 与字符串删除相关的方法有 4 个，他们分别是 pop()，remove()，truncate()，clear()。这四个方法仅适用于 String 类型。\n1、 pop —— 删除并返回字符串的最后一个字符\n该方法是直接操作原来的字符串。但是存在返回值，其返回值是一个 Option 类型，如果字符串为空，则返回 None。\n1 2 3 4 5 6 7 8 fn main() { let mut string_pop = String::from(\u0026#34;rust pop 中文!\u0026#34;); let p1 = string_pop.pop(); let p2 = string_pop.pop(); dbg!(p1); dbg!(p2); dbg!(string_pop); } 2、 remove —— 删除并返回字符串中指定位置的字符\n该方法是直接操作原来的字符串。但是存在返回值，其返回值是删除位置的字符串，只接收一个参数，表示该字符起始索引位置。remove() 方法是按照字节来处理字符串的，如果参数所给的位置不是合法的字符边界，则会发生错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 fn main() { let mut string_remove = String::from(\u0026#34;测试remove方法\u0026#34;); println!( \u0026#34;string_remove 占 {} 个字节\u0026#34;, std::mem::size_of_val(string_remove.as_str()) ); // 删除第一个汉字 string_remove.remove(0); // 下面代码会发生错误 // string_remove.remove(1); // 直接删除第二个汉字 // string_remove.remove(3); dbg!(string_remove); } 3、truncate —— 删除字符串中从指定位置开始到结尾的全部字符\n该方法是直接操作原来的字符串。无返回值。该方法 truncate() 方法是按照字节来处理字符串的，如果参数所给的位置不是合法的字符边界，则会发生错误。\n1 2 3 4 5 fn main() { let mut string_truncate = String::from(\u0026#34;测试truncate\u0026#34;); string_truncate.truncate(3); dbg!(string_truncate); } 1 string_truncate = \u0026#34;测\u0026#34; 4、clear —— 清空字符串\n该方法是直接操作原来的字符串。调用后，删除字符串中的所有字符，相当于 truncate() 方法参数为 0 的时候。\n1 2 3 4 5 fn main() { let mut string_clear = String::from(\u0026#34;string clear\u0026#34;); string_clear.clear(); dbg!(string_clear); } 连接 (Concatenate) 1、使用 + 或者 += 连接字符串\n使用 + 或者 += 连接字符串，要求右边的参数必须为字符串的切片引用（Slice）类型。其实当调用 + 的操作符时，相当于调用了 std::string 标准库中的 add() 方法，这里 add() 方法的第二个参数是一个引用的类型。因此我们在使用 +， 必须传递切片引用类型。不能直接传递 String 类型。+ 和 += 都是返回一个新的字符串。所以变量声明可以不需要 mut 关键字修饰。\n1 2 3 4 5 6 7 8 9 10 11 fn main() { let string_append = String::from(\u0026#34;hello \u0026#34;); let string_rust = String::from(\u0026#34;rust\u0026#34;); // \u0026amp;string_rust会自动解引用为\u0026amp;str // 在下句中，string_append的所有权被转移走了，因此后面不能再使用string_append let result = string_append + \u0026amp;string_rust; let mut result = result + \u0026#34;!\u0026#34;; result += \u0026#34;!!!\u0026#34;; println!(\u0026#34;连接字符串 + -\u0026gt; {}\u0026#34;, result); } 2、使用 format! 连接字符串\nformat! 这种方式适用于 String 和 \u0026amp;str 。format! 的用法与 print! 的用法类似。\n1 2 3 4 5 6 fn main() { let s1 = \u0026#34;hello\u0026#34;; let s2 = String::from(\u0026#34;rust\u0026#34;); let s = format!(\u0026#34;{} {}!\u0026#34;, s1, s2); println!(\u0026#34;{}\u0026#34;, s); } 1 hello rust! 字符串转义 转义输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 fn main() { // 通过 \\ + 字符的十六进制表示，转义输出一个字符 let byte_escape = \u0026#34;I\u0026#39;m writing \\x52\\x75\\x73\\x74!\u0026#34;; println!(\u0026#34;What are you doing\\x3F (\\\\x3F means ?) {}\u0026#34;, byte_escape); // \\u 可以输出一个 unicode 字符 let unicode_codepoint = \u0026#34;\\u{211D}\u0026#34;; let character_name = \u0026#34;\\\u0026#34;DOUBLE-STRUCK CAPITAL R\\\u0026#34;\u0026#34;; println!( \u0026#34;Unicode character {} (U+211D) is called {}\u0026#34;, unicode_codepoint, character_name ); // 换行了也会保持之前的字符串格式 let long_string = \u0026#34;String literals can span multiple lines. The linebreak and indentation here -\u0026gt;\\ \u0026lt;- can be escaped too!\u0026#34;; println!(\u0026#34;{}\u0026#34;, long_string); } 保持原样\n1 2 3 4 5 6 7 8 9 10 11 12 13 fn main() { println!(\u0026#34;{}\u0026#34;, \u0026#34;hello \\\\x52\\\\x75\\\\x73\\\\x74\u0026#34;); let raw_str = r\u0026#34;Escapes don\u0026#39;t work here: \\x3F \\u{211D}\u0026#34;; println!(\u0026#34;{}\u0026#34;, raw_str); // 如果字符串包含双引号，可以在开头和结尾加 # let quotes = r#\u0026#34;And then I said: \u0026#34;There is no escape!\u0026#34;\u0026#34;#; println!(\u0026#34;{}\u0026#34;, quotes); // 如果还是有歧义，可以继续增加，没有限制 let longer_delimiter = r###\u0026#34;A string with \u0026#34;# in it. And even \u0026#34;##!\u0026#34;###; println!(\u0026#34;{}\u0026#34;, longer_delimiter); } 操作UTF-8字符串 字符\n如果你想要以 Unicode 字符的方式遍历字符串，最好的办法是使用 chars 方法，例如：\n1 2 3 for c in \u0026#34;中国人\u0026#34;.chars() { println!(\u0026#34;{}\u0026#34;, c); } 字节\n这种方式是返回字符串的底层字节数组表现形式：\n1 2 3 for b in \u0026#34;中国人\u0026#34;.bytes() { println!(\u0026#34;{}\u0026#34;, b); } 获取子串\n想要准确的从 UTF-8 字符串中获取子串是较为复杂的事情，例如想要从 holla中国人नमस्ते 这种变长的字符串中取出某一个子串，使用标准库你是做不到的。 你需要在 crates.io 上搜索 utf8 来寻找想要的功能。\n可以考虑尝试下这个库：utf8_slice。\n元组 元组是由多种类型组合到一起形成的，因此它是复合类型，元组的长度是固定的，元组中元素的顺序也是固定的。\n可以通过以下语法创建一个元组：\n1 2 3 fn main() { let tup: (i32, f64, u8) = (500, 6.4, 1); } 用模式匹配解构元组 1 2 3 4 5 6 7 fn main() { let tup = (500, 6.4, 1); let (x, y, z) = tup; println!(\u0026#34;The value of y is: {}\u0026#34;, y); } 用 . 来访问元组 1 2 3 4 5 6 7 8 9 fn main() { let x: (i32, f64, u8) = (500, 6.4, 1); let five_hundred = x.0; let six_point_four = x.1; let one = x.2; } 结构体 结构体跟之前讲过的元组有些相像：都是由多种类型组合而成。但是与元组不同的是，结构体可以为内部的每个字段起一个富有含义的名称。因此结构体更加灵活更加强大，你无需依赖这些字段的顺序来访问和解析它\n结构体语法 定义结构体\n一个结构体由几部分组成：\n通过关键字 struct 定义 一个清晰明确的结构体 名称 几个有名字的结构体 字段 例如，该结构体名称是 User，拥有 4 个字段，且每个字段都有对应的字段名及类型声明，例如 username 代表了用户名，是一个可变的 String 类型。\n1 2 3 4 5 6 struct User { active: bool, username: String, email: String, sign_in_count: u64, } 创建结构体实例\n为了使用上述结构体，我们需要创建 User 结构体的实例：\n1 2 3 4 5 6 let user1 = User { email: String::from(\u0026#34;someone@example.com\u0026#34;), username: String::from(\u0026#34;someusername123\u0026#34;), active: true, sign_in_count: 1, }; 有几点值得注意:\n初始化实例时，每个字段都需要进行初始化 初始化时的字段顺序不需要和结构体定义时的顺序一致 访问结构体字段\n通过 . 操作符即可访问结构体实例内部的字段值，也可以修改它们：\n1 2 3 4 5 6 7 8 let mut user1 = User { email: String::from(\u0026#34;someone@example.com\u0026#34;), username: String::from(\u0026#34;someusername123\u0026#34;), active: true, sign_in_count: 1, }; user1.email = String::from(\u0026#34;anotheremail@example.com\u0026#34;); 需要注意的是，必须要将结构体实例声明为可变的，才能修改其中的字段，Rust 不支持将某个结构体某个字段标记为可变。\n简化结构体创建\n1 2 3 4 5 6 7 8 fn build_user(email: String, username: String) -\u0026gt; User { User { email, username, active: true, sign_in_count: 1, } } 如上所示，当函数参数和结构体字段同名时，可以直接使用缩略的方式进行初始化，跟 TypeScript 中一模一样。\n结构体更新语法\n在实际场景中，有一种情况很常见：根据已有的结构体实例，创建新的结构体实例，例如根据已有的 user1 实例来构建 user2：\n1 2 3 4 5 6 let user2 = User { active: user1.active, username: user1.username, email: String::from(\u0026#34;another@example.com\u0026#34;), sign_in_count: user1.sign_in_count, }; 简化版：\n1 2 3 4 let user2 = User { email: String::from(\u0026#34;another@example.com\u0026#34;), ..user1 }; .. 语法表明凡是我们没有显式声明的字段，全部从 user1 中自动获取。需要注意的是 ..user1 必须在结构体的尾部使用。\n","date":"2022-09-14T14:08:08+08:00","permalink":"https://figureair.github.io/p/rust%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/","title":"Rust学习随笔-复合类型"}]