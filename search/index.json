[{"content":"前言 生活节奏的逐渐加快和疫情带来的浮躁，已经让我很难沉下心去看完一场电影。而多亏自己以前会有在微博记录电影观后感的习惯，我翻了翻主页，距离我上次看电影已经有6个月的跨度了。当然了，今天不是来聊这半年为什么我无法沉浸在一部电影里以及这一现象带来的的反思（先挖个坑），而是来讲讲这一次观看的《壮志凌云2：独行侠》（亦或者《美式战狼2》）。\n我不准备从剧情的前后来记录流水账（这没有意义），也不准备娓娓而谈，深挖细节（我好像做不到）。只是随性而写，把电影里一些我感到有趣的地方以及当时的想法描绘一番。文笔不佳，还请见谅，以后努力。\n好的续集需要做到什么？ 当我把电影下载到桌面，鼠标移动到图标上时，我的第一个念头不是“这部片子会不会好看”，而是“我会不会看不懂剧情”，毕竟这是一部续集电影，而续集电影往往需要有粘性的观众，能够了解前作的相关背景。而我对前作的认知，仅仅停留在它的上映时间1986年和主角汤姆·克鲁斯。于是，我忐忑的打开播放器，在派拉蒙的影标过后，是一小段战斗飞行学校的介绍（我暗暗地点了点头）。而汤姆·克鲁斯的出现，让我一边感慨59岁的他依旧如此帅气，一边也开始好奇这位昔日主角——独行侠将面临怎样的新故事，而他的旧故事又是什么。\n随着剧情的发展，我认识了“冰人”（独行侠的好友兼上司）、“笨鹅”（独行侠早年牺牲的僚机）、“公鸡”（笨鹅的儿子），潘妮（英雄配美人）以及新一代的精英飞行员们。于是通过一次教学、一场冲突、一个任务，电影不仅将现在的故事讲的详实和引人，更将往事勾勒了出来。意外的牺牲，独行侠的消沉，似乎就是前作的关键点。反过来，正因为这些时不时的背景提示，我便越发的能代入到续集故事的展开中。牺牲带来的矛盾，类似场景的抉择，新旧人物的成长，这些都将前后电影串联交错了起来。\n我们回到这一小节的标题，好的续集需要做到什么？对我而言，《壮志凌云2》交了一份满意的答卷。第一，以恰当的方式交代前作，不是旁白念一遍。这是很重要的，因为对于新老观众，新观众需要知道前作的背景来搞明白续作，又不希望降低观看体验，老观众需要以此唤醒往日的情怀。而在看完以后，我已经大概了解了《壮志凌云》发生了什么，甚至有动力去探求前作。第二，理念的一脉相承和变化。在不变中求变，的确挺难的。纵观这部电影，不变的是空战？是独行侠？还是那句“Don\u0026rsquo;t think! Just do!”？或许都是，毕竟我没看过前作嘛（笑），不过我相信两部电影的36年的时间跨度，汤姆·克鲁斯24岁到60岁的老去，都已经说明了变化。\n另外，演员找的真好，“笨鹅”和“公鸡”简直长得一模一样。附一张“公鸡”的图。\n我喜欢HappyEnding 我一直很喜欢HappyEnding。沉重的结局虽然能够带给人思考，但生活已经很累了，为什么不寻找点快乐呢。在前作中，“笨鹅”牺牲了，所以在观看中，我一直在担心独行侠会不会牺牲？“公鸡”会不会牺牲？僚机会不会坠毁？甚至于，当独行侠立了两次Flag，我心里想，寄了，独行侠绝对回不来了。下面两张，是立Flag现场。\n还好还好，虽然飞机被导弹击毁，但弹射成功；虽然被直升机扫射，但“公鸡”一发导弹救命；虽然“公鸡”也被迫弹射，但溜进敌方基地偷到了飞机；虽然被两架五代机追，但独行侠一打二有惊无险；虽然又有一架五代机出现而且弹射装置失灵，但支援队友的出现，又续住了。\n相较于影片前中期的紧张，反而后期有点轻松的感觉。每当以为牺牲的时候，我心里想这可是主角啊，但转念一想，主角凉了不更升华（哭笑）？还好，编剧很仁慈，总是给予他们转机，甚至让他们玩起了美式幽默。尤其两个场景，一是“公鸡”和独行侠在飞机坠毁后雪地里的对话，我情不自禁的笑了出来，建议看原片更有感觉。\n二是，独行侠尝试蒙混过关，和敌方飞行员在高空进行手势交流，结果弄巧成拙，机上两人的吐槽也挺有意思。\n而在最后，全员安全归来，航母上的所有人在甲板上欢呼的场景，我相信所有人看到这都会由衷的一笑。虽然剧情老套，但谁能说这不百试百灵呢？\n21世纪的画面 对于电影画面，我一直希望是尽善尽美。他的前辈毕竟是1986年的老片了，而《壮志凌云2》又能在21世纪展现出什么样的画面呢？我只能说，它满足了我的渴求。\n当影片开头，战机突破音速划过地表，画面再切回独行侠坐在机舱里，我竟然有了一种看《星际穿越》的感觉。\n之后战机因为超10g解体划过天空，也美轮美奂。\n同时《壮志凌云2》是一部空战片，激烈的空战也最能吸睛。这里只截一张敌机躲避导弹的场景吧，我不太懂军事和战机，也不清楚这一操作叫什么，只是看到飞机直接悬空与导弹擦肩而过的这一幕，我和片中的克鲁斯一起喊出了“What?”\n征兵宣传片 《壮志凌云2》很出色的表现了美国空军的风姿，无论是开头的超10g飞行，还是后期的F-14低空飞行精准摧毁核设施，以及打五代机的空战，每一幕都可以说让人血脉贲张。听说《壮志凌云》在当时的那个年代极大的提高美国的入伍率，而到现在，我相信依旧会有很多幼小的心灵因为这部电影而希望成为一名飞行员。外加影片中出现的各式战机，让人大呼过瘾。在最后，美国国防部（还是美国空军？）出现在了支持名单里，一切就解释的通了。\n我只是希望在未来，我们的市场也可以有这样类型的电影（或许已经有了？），无论是空军、陆军还是海军，不单单是讲一个故事，更是以电影的渠道去输出一个大国、强国的形象，将强大的武器给展现出来（好像不符合战忽局宗旨）。\n不完美才是完美 当然一部电影不可能十全十美，同时对于不同的人，口味不同自然对待这部电影的感官也不同。恰如一句谚语所说，“缺点很少，意味着优点也很少”。其实仔细推敲，这部电影也有很多地方的漏洞，那我也来挑一下刺。\n第一，剧情老套，大家都知道发生了什么，也知道未来会发生什么，不是吗（笑）？主角的一系列遭遇，基本都离不开矛盾、心结，再加点爱情、友情的佐料，最后主角英雄般的无敌，就构成了整个大纲。或许在某些细节会有些许不同，但大体流程都已经敲定的情况下，我对剧情的期待其实没有太多。\n第二，逻辑有bug。一个问题，溜进敌方机场偷飞机要几步？答案很明显，两步，一是溜进敌方机场，二是偷飞机（摊手）。我不是重复，我只是把影片所展现的如实的说了出来。没有任何阻拦，没有任何意外，偷一架F-14就是这么简单（无奈）。另外是，F-14真的能打赢两架五代机苏57吗？真的如片中所说，不取决于飞机，而取决于飞行员？看完以后，我特地去查了一下F-14属于几代机，好吧，是三代机，我只能说，要相信主角光环好吧，越两级挑战不是梦。\n独行侠的故事已经结束，当我回望，心里总有一些唏嘘。我们看过一个又一个主角的人生，而对自己的人生又有什么样的想法呢？\n散言碎语 看电影的时候肯定有更多想法，但看完后也只留存了部分思绪，毕竟不能边看边写嘛。\n另外，已经很久没有写过那么多字了，读了理工科四年，外加网文浸染，短视频荼毒，如果你艰难的读到了这，先说一声抱歉，以后会尽可能提高文学水平，让阅读体验更加良好。\n其实，写Blog也是一种尝试，一方面是为了整理归纳一些想法和学习的资料，另一方面呢，也是为了让自己的心能够平静下来，不再过于追求快节奏和及时的快乐，尝试写一些生活碎片去充盈自己的精神世界。\n当然，日后若有些许闲暇，我也会继续坚持下去。\n","date":"2022-09-23T21:17:57+08:00","image":"https://figureair.github.io/p/%E5%A3%AE%E5%BF%97%E5%87%8C%E4%BA%912%E7%8B%AC%E8%A1%8C%E4%BE%A0/title_hu78a886fe06ca1dd6c0c63ded705446d4_930223_120x120_fill_q75_box_smart1.jpeg","permalink":"https://figureair.github.io/p/%E5%A3%AE%E5%BF%97%E5%87%8C%E4%BA%912%E7%8B%AC%E8%A1%8C%E4%BE%A0/","title":"壮志凌云2：独行侠"},{"content":"前言 大部分内容摘录自《Rust语言圣经》，仅用于自主复习。\n字符串与切片 切片 一个示例代码和错误解析\n1 2 3 4 5 6 7 8 9 10 11 12 fn main() { let mut s = String::from(\u0026#34;hello world\u0026#34;); let word = first_word(\u0026amp;s); s.clear(); // error! println!(\u0026#34;the first word is: {}\u0026#34;, word); } fn first_word(s: \u0026amp;String) -\u0026gt; \u0026amp;str { \u0026amp;s[..1] } 错误原因：当我们已经有了可变借用时，就无法再拥有不可变的借用。因为 clear 需要清空改变 String，因此它需要一个可变借用（利用 VSCode 可以看到该方法的声明是 pub fn clear(\u0026amp;mut self) ，参数是对自身的可变借用 ）；而之后的 println! 又使用了不可变借用，也就是在 s.clear() 处可变借用与不可变借用试图同时生效，因此编译无法通过。\nRust中的字符串 当 Rust 用户提到字符串时，往往指的就是 String 类型和 \u0026amp;str 字符串切片类型，这两个类型都是 UTF-8 编码。\nString 与 \u0026amp;str 的转换 在之前的代码中，已经见到好几种从 \u0026amp;str 类型生成 String 类型的操作：\nString::from(\u0026quot;hello,world\u0026quot;) \u0026quot;hello,world\u0026quot;.to_string() 那么如何将 String 类型转为 \u0026amp;str 类型呢？答案很简单，取引用即可：\n1 2 3 4 5 6 7 8 9 10 fn main() { let s = String::from(\u0026#34;hello,world!\u0026#34;); say_hello(\u0026amp;s); say_hello(\u0026amp;s[..]); say_hello(s.as_str()); } fn say_hello(s: \u0026amp;str) { println!(\u0026#34;{}\u0026#34;,s); } 字符串切片 字符串切片是非常危险的操作，因为切片的索引是通过字节来进行，但是字符串又是 UTF-8 编码，因此你无法保证索引的字节刚好落在字符的边界上，例如：\n1 2 3 let hello = \u0026#34;中国人\u0026#34;; let s = \u0026amp;hello[0..2]; 运行上面的程序，会直接造成崩溃。我们索引的字节落在了 中 字符的内部，这种返回没有任何意义。因此在通过索引区间来访问字符串时，需要格外的小心，一不注意，就会导致你程序的崩溃！\n操作字符串 追加 (Push) 在字符串尾部可以使用 push() 方法追加字符 char，也可以使用 push_str() 方法追加字符串字面量。这两个方法都是在原有的字符串上追加，并不会返回新的字符串。由于字符串追加操作要修改原来的字符串，则该字符串必须是可变的，即字符串变量必须由 mut 关键字修饰。\n1 2 3 4 5 6 7 8 fn main() { let mut s = String::from(\u0026#34;Hello \u0026#34;); s.push(\u0026#39;r\u0026#39;); println!(\u0026#34;追加字符 push() -\u0026gt; {}\u0026#34;, s); s.push_str(\u0026#34;ust!\u0026#34;); println!(\u0026#34;追加字符串 push_str() -\u0026gt; {}\u0026#34;, s); } 插入 (Insert) 可以使用 insert() 方法插入单个字符 char，也可以使用 insert_str() 方法插入字符串字面量，与 push() 方法不同，这俩方法需要传入两个参数，第一个参数是字符（串）插入位置的索引，第二个参数是要插入的字符（串），索引从 0 开始计数，如果越界则会发生错误。由于字符串插入操作要修改原来的字符串，则该字符串必须是可变的，即字符串变量必须由 mut 关键字修饰。\n1 2 3 4 5 6 7 fn main() { let mut s = String::from(\u0026#34;Hello rust!\u0026#34;); s.insert(5, \u0026#39;,\u0026#39;); println!(\u0026#34;插入字符 insert() -\u0026gt; {}\u0026#34;, s); s.insert_str(6, \u0026#34; I like\u0026#34;); println!(\u0026#34;插入字符串 insert_str() -\u0026gt; {}\u0026#34;, s); } 替换 (Replace) 1、replace\n该方法可适用于 String 和 \u0026amp;str 类型。replace() 方法接收两个参数，第一个参数是要被替换的字符串，第二个参数是新的字符串。该方法会替换所有匹配到的字符串。该方法是返回一个新的字符串，而不是操作原来的字符串。\n1 2 3 4 5 fn main() { let string_replace = String::from(\u0026#34;I like rust. Learning rust is my favorite!\u0026#34;); let new_string_replace = string_replace.replace(\u0026#34;rust\u0026#34;, \u0026#34;RUST\u0026#34;); dbg!(new_string_replace); } 2、replacen\n该方法可适用于 String 和 \u0026amp;str 类型。replacen() 方法接收三个参数，前两个参数与 replace() 方法一样，第三个参数则表示替换的个数。该方法是返回一个新的字符串，而不是操作原来的字符串。\n1 2 3 4 5 fn main() { let string_replace = \u0026#34;I like rust. Learning rust is my favorite!\u0026#34;; let new_string_replacen = string_replace.replacen(\u0026#34;rust\u0026#34;, \u0026#34;RUST\u0026#34;, 1); dbg!(new_string_replacen); } 3、replace_range\n该方法仅适用于 String 类型。replace_range 接收两个参数，第一个参数是要替换字符串的范围（Range），第二个参数是新的字符串。该方法是直接操作原来的字符串，不会返回新的字符串。该方法需要使用 mut 关键字修饰。\n1 2 3 4 5 fn main() { let mut string_replace_range = String::from(\u0026#34;I like rust!\u0026#34;); string_replace_range.replace_range(7..8, \u0026#34;R\u0026#34;); dbg!(string_replace_range); } 删除 (Delete) 与字符串删除相关的方法有 4 个，他们分别是 pop()，remove()，truncate()，clear()。这四个方法仅适用于 String 类型。\n1、 pop —— 删除并返回字符串的最后一个字符\n该方法是直接操作原来的字符串。但是存在返回值，其返回值是一个 Option 类型，如果字符串为空，则返回 None。\n1 2 3 4 5 6 7 8 fn main() { let mut string_pop = String::from(\u0026#34;rust pop 中文!\u0026#34;); let p1 = string_pop.pop(); let p2 = string_pop.pop(); dbg!(p1); dbg!(p2); dbg!(string_pop); } 2、 remove —— 删除并返回字符串中指定位置的字符\n该方法是直接操作原来的字符串。但是存在返回值，其返回值是删除位置的字符串，只接收一个参数，表示该字符起始索引位置。remove() 方法是按照字节来处理字符串的，如果参数所给的位置不是合法的字符边界，则会发生错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 fn main() { let mut string_remove = String::from(\u0026#34;测试remove方法\u0026#34;); println!( \u0026#34;string_remove 占 {} 个字节\u0026#34;, std::mem::size_of_val(string_remove.as_str()) ); // 删除第一个汉字 string_remove.remove(0); // 下面代码会发生错误 // string_remove.remove(1); // 直接删除第二个汉字 // string_remove.remove(3); dbg!(string_remove); } 3、truncate —— 删除字符串中从指定位置开始到结尾的全部字符\n该方法是直接操作原来的字符串。无返回值。该方法 truncate() 方法是按照字节来处理字符串的，如果参数所给的位置不是合法的字符边界，则会发生错误。\n1 2 3 4 5 fn main() { let mut string_truncate = String::from(\u0026#34;测试truncate\u0026#34;); string_truncate.truncate(3); dbg!(string_truncate); } 1 string_truncate = \u0026#34;测\u0026#34; 4、clear —— 清空字符串\n该方法是直接操作原来的字符串。调用后，删除字符串中的所有字符，相当于 truncate() 方法参数为 0 的时候。\n1 2 3 4 5 fn main() { let mut string_clear = String::from(\u0026#34;string clear\u0026#34;); string_clear.clear(); dbg!(string_clear); } 连接 (Concatenate) 1、使用 + 或者 += 连接字符串\n使用 + 或者 += 连接字符串，要求右边的参数必须为字符串的切片引用（Slice）类型。其实当调用 + 的操作符时，相当于调用了 std::string 标准库中的 add() 方法，这里 add() 方法的第二个参数是一个引用的类型。因此我们在使用 +， 必须传递切片引用类型。不能直接传递 String 类型。+ 和 += 都是返回一个新的字符串。所以变量声明可以不需要 mut 关键字修饰。\n1 2 3 4 5 6 7 8 9 10 11 fn main() { let string_append = String::from(\u0026#34;hello \u0026#34;); let string_rust = String::from(\u0026#34;rust\u0026#34;); // \u0026amp;string_rust会自动解引用为\u0026amp;str // 在下句中，string_append的所有权被转移走了，因此后面不能再使用string_append let result = string_append + \u0026amp;string_rust; let mut result = result + \u0026#34;!\u0026#34;; result += \u0026#34;!!!\u0026#34;; println!(\u0026#34;连接字符串 + -\u0026gt; {}\u0026#34;, result); } 2、使用 format! 连接字符串\nformat! 这种方式适用于 String 和 \u0026amp;str 。format! 的用法与 print! 的用法类似。\n1 2 3 4 5 6 fn main() { let s1 = \u0026#34;hello\u0026#34;; let s2 = String::from(\u0026#34;rust\u0026#34;); let s = format!(\u0026#34;{} {}!\u0026#34;, s1, s2); println!(\u0026#34;{}\u0026#34;, s); } 1 hello rust! 字符串转义 转义输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 fn main() { // 通过 \\ + 字符的十六进制表示，转义输出一个字符 let byte_escape = \u0026#34;I\u0026#39;m writing \\x52\\x75\\x73\\x74!\u0026#34;; println!(\u0026#34;What are you doing\\x3F (\\\\x3F means ?) {}\u0026#34;, byte_escape); // \\u 可以输出一个 unicode 字符 let unicode_codepoint = \u0026#34;\\u{211D}\u0026#34;; let character_name = \u0026#34;\\\u0026#34;DOUBLE-STRUCK CAPITAL R\\\u0026#34;\u0026#34;; println!( \u0026#34;Unicode character {} (U+211D) is called {}\u0026#34;, unicode_codepoint, character_name ); // 换行了也会保持之前的字符串格式 let long_string = \u0026#34;String literals can span multiple lines. The linebreak and indentation here -\u0026gt;\\ \u0026lt;- can be escaped too!\u0026#34;; println!(\u0026#34;{}\u0026#34;, long_string); } 保持原样\n1 2 3 4 5 6 7 8 9 10 11 12 13 fn main() { println!(\u0026#34;{}\u0026#34;, \u0026#34;hello \\\\x52\\\\x75\\\\x73\\\\x74\u0026#34;); let raw_str = r\u0026#34;Escapes don\u0026#39;t work here: \\x3F \\u{211D}\u0026#34;; println!(\u0026#34;{}\u0026#34;, raw_str); // 如果字符串包含双引号，可以在开头和结尾加 # let quotes = r#\u0026#34;And then I said: \u0026#34;There is no escape!\u0026#34;\u0026#34;#; println!(\u0026#34;{}\u0026#34;, quotes); // 如果还是有歧义，可以继续增加，没有限制 let longer_delimiter = r###\u0026#34;A string with \u0026#34;# in it. And even \u0026#34;##!\u0026#34;###; println!(\u0026#34;{}\u0026#34;, longer_delimiter); } 操作UTF-8字符串 字符\n如果你想要以 Unicode 字符的方式遍历字符串，最好的办法是使用 chars 方法，例如：\n1 2 3 for c in \u0026#34;中国人\u0026#34;.chars() { println!(\u0026#34;{}\u0026#34;, c); } 字节\n这种方式是返回字符串的底层字节数组表现形式：\n1 2 3 for b in \u0026#34;中国人\u0026#34;.bytes() { println!(\u0026#34;{}\u0026#34;, b); } 获取子串\n想要准确的从 UTF-8 字符串中获取子串是较为复杂的事情，例如想要从 holla中国人नमस्ते 这种变长的字符串中取出某一个子串，使用标准库你是做不到的。 你需要在 crates.io 上搜索 utf8 来寻找想要的功能。\n可以考虑尝试下这个库：utf8_slice。\n元组 元组是由多种类型组合到一起形成的，因此它是复合类型，元组的长度是固定的，元组中元素的顺序也是固定的。\n可以通过以下语法创建一个元组：\n1 2 3 fn main() { let tup: (i32, f64, u8) = (500, 6.4, 1); } 用模式匹配解构元组 1 2 3 4 5 6 7 fn main() { let tup = (500, 6.4, 1); let (x, y, z) = tup; println!(\u0026#34;The value of y is: {}\u0026#34;, y); } 用 . 来访问元组 1 2 3 4 5 6 7 8 9 fn main() { let x: (i32, f64, u8) = (500, 6.4, 1); let five_hundred = x.0; let six_point_four = x.1; let one = x.2; } 结构体 结构体跟之前讲过的元组有些相像：都是由多种类型组合而成。但是与元组不同的是，结构体可以为内部的每个字段起一个富有含义的名称。因此结构体更加灵活更加强大，你无需依赖这些字段的顺序来访问和解析它\n结构体语法 定义结构体\n一个结构体由几部分组成：\n通过关键字 struct 定义 一个清晰明确的结构体 名称 几个有名字的结构体 字段 例如，该结构体名称是 User，拥有 4 个字段，且每个字段都有对应的字段名及类型声明，例如 username 代表了用户名，是一个可变的 String 类型。\n1 2 3 4 5 6 struct User { active: bool, username: String, email: String, sign_in_count: u64, } 创建结构体实例\n为了使用上述结构体，我们需要创建 User 结构体的实例：\n1 2 3 4 5 6 let user1 = User { email: String::from(\u0026#34;someone@example.com\u0026#34;), username: String::from(\u0026#34;someusername123\u0026#34;), active: true, sign_in_count: 1, }; 有几点值得注意:\n初始化实例时，每个字段都需要进行初始化 初始化时的字段顺序不需要和结构体定义时的顺序一致 访问结构体字段\n通过 . 操作符即可访问结构体实例内部的字段值，也可以修改它们：\n1 2 3 4 5 6 7 8 let mut user1 = User { email: String::from(\u0026#34;someone@example.com\u0026#34;), username: String::from(\u0026#34;someusername123\u0026#34;), active: true, sign_in_count: 1, }; user1.email = String::from(\u0026#34;anotheremail@example.com\u0026#34;); 需要注意的是，必须要将结构体实例声明为可变的，才能修改其中的字段，Rust 不支持将某个结构体某个字段标记为可变。\n简化结构体创建\n1 2 3 4 5 6 7 8 fn build_user(email: String, username: String) -\u0026gt; User { User { email, username, active: true, sign_in_count: 1, } } 如上所示，当函数参数和结构体字段同名时，可以直接使用缩略的方式进行初始化，跟 TypeScript 中一模一样。\n结构体更新语法\n在实际场景中，有一种情况很常见：根据已有的结构体实例，创建新的结构体实例，例如根据已有的 user1 实例来构建 user2：\n1 2 3 4 5 6 let user2 = User { active: user1.active, username: user1.username, email: String::from(\u0026#34;another@example.com\u0026#34;), sign_in_count: user1.sign_in_count, }; 简化版：\n1 2 3 4 let user2 = User { email: String::from(\u0026#34;another@example.com\u0026#34;), ..user1 }; .. 语法表明凡是我们没有显式声明的字段，全部从 user1 中自动获取。需要注意的是 ..user1 必须在结构体的尾部使用。\n","date":"2022-09-14T14:08:08+08:00","permalink":"https://figureair.github.io/p/rust%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/","title":"Rust学习随笔-复合类型"}]